<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">

<head>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
  <link rel="stylesheet" href="../style_bootstrap.css">
  <link rel="stylesheet" href="../css/style.css">
  <link href="https://cdn.prod.website-files.com/5efdb54f07a6812bcd95cc65/6773d0fc3013e060f08d7145_favicon.jpg"
    rel="shortcut icon" type="image/x-icon">
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Day 2: Working with JSON Data</title>
  <style>
    code {
      white-space: pre-wrap;
    }

    span.smallcaps {
      font-variant: small-caps;
    }

    span.underline {
      text-decoration: underline;
    }

    div.column {
      display: inline-block;
      vertical-align: top;
      width: 50%;
    }

    div.hanging-indent {
      margin-left: 1.5em;
      text-indent: -1.5em;
    }

    ul.task-list {
      list-style: none;
    }

    pre>code.sourceCode {
      white-space: pre;
      position: relative;
    }

    pre>code.sourceCode>span {
      display: inline-block;
      line-height: 1.25;
    }

    pre>code.sourceCode>span:empty {
      height: 1.2em;
    }

    code.sourceCode>span {
      color: inherit;
      text-decoration: inherit;
    }

    div.sourceCode {
      margin: 1em 0;
    }

    pre.sourceCode {
      margin: 0;
    }

    @media screen {
      div.sourceCode {
        overflow: auto;
      }
    }

    @media print {
      pre>code.sourceCode {
        white-space: pre-wrap;
      }

      pre>code.sourceCode>span {
        text-indent: -5em;
        padding-left: 5em;
      }
    }

    pre.numberSource code {
      counter-reset: source-line 0;
    }

    pre.numberSource code>span {
      position: relative;
      left: -4em;
      counter-increment: source-line;
    }

    pre.numberSource code>span>a:first-child::before {
      content: counter(source-line);
      position: relative;
      left: -1em;
      text-align: right;
      vertical-align: baseline;
      border: none;
      display: inline-block;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      padding: 0 4px;
      width: 4em;
      color: #aaaaaa;
    }

    pre.numberSource {
      margin-left: 3em;
      border-left: 1px solid #aaaaaa;
      padding-left: 4px;
    }

    div.sourceCode {}

    @media screen {
      pre>code.sourceCode>span>a:first-child::before {
        text-decoration: underline;
      }
    }

    code span.al {
      color: #ff0000;
      font-weight: bold;
    }

    /* Alert */
    code span.an {
      color: #60a0b0;
      font-weight: bold;
      font-style: italic;
    }

    /* Annotation */
    code span.at {
      color: #7d9029;
    }

    /* Attribute */
    code span.bn {
      color: #40a070;
    }

    /* BaseN */
    code span.bu {}

    /* BuiltIn */
    code span.cf {
      color: #007020;
      font-weight: bold;
    }

    /* ControlFlow */
    code span.ch {
      color: #4070a0;
    }

    /* Char */
    code span.cn {
      color: #880000;
    }

    /* Constant */
    code span.co {
      color: #60a0b0;
      font-style: italic;
    }

    /* Comment */
    code span.cv {
      color: #60a0b0;
      font-weight: bold;
      font-style: italic;
    }

    /* CommentVar */
    code span.do {
      color: #ba2121;
      font-style: italic;
    }

    /* Documentation */
    code span.dt {
      color: #902000;
    }

    /* DataType */
    code span.dv {
      color: #40a070;
    }

    /* DecVal */
    code span.er {
      color: #ff0000;
      font-weight: bold;
    }

    /* Error */
    code span.ex {}

    /* Extension */
    code span.fl {
      color: #40a070;
    }

    /* Float */
    code span.fu {
      color: #06287e;
    }

    /* Function */
    code span.im {}

    /* Import */
    code span.in {
      color: #60a0b0;
      font-weight: bold;
      font-style: italic;
    }

    /* Information */
    code span.kw {
      color: #007020;
      font-weight: bold;
    }

    /* Keyword */
    code span.op {
      color: #666666;
    }

    /* Operator */
    code span.ot {
      color: #007020;
    }

    /* Other */
    code span.pp {
      color: #bc7a00;
    }

    /* Preprocessor */
    code span.sc {
      color: #4070a0;
    }

    /* SpecialChar */
    code span.ss {
      color: #bb6688;
    }

    /* SpecialString */
    code span.st {
      color: #4070a0;
    }

    /* String */
    code span.va {
      color: #19177c;
    }

    /* Variable */
    code span.vs {
      color: #4070a0;
    }

    /* VerbatimString */
    code span.wa {
      color: #60a0b0;
      font-weight: bold;
      font-style: italic;
    }

    /* Warning */
  </style>
</head>

<body>
  <div class="copy-notification" id="copyNotification">Copied!</div>

  <div id="europeanunion-turkey">
    <img src="../static/eu.png" alt="">
  </div>
  <div id="sanayiteknolojibakan">
    <img src="../static/sanayitek.png" alt="">
  </div>
  <div id="rekabet">
    <img src="../static/rekabet.png" alt="">
  </div>
  <div id="tisk">
    <img src="../static/tisk.png" alt="">
  </div>
  <div id="undp">
    <img src="../static/undp.png" alt="">
  </div>
  <div class="content-container">
    <div class="container">
      <section>
        <h1 id="day-2-working-with-json-data">Day 2: Working with JSON Data</h1>
        <h2 id="session-4-working-with-json-data-2-hours">Session 4: Working with JSON Data (2 hours)</h2>
        <p>JSON (JavaScript Object Notation) has become a standard format for data interchange and is increasingly used
          for storing semi-structured data within relational databases. Most modern RDBMS offer ways to store, query,
          and
          index JSON data, though the specific features, data types, and syntax vary.</p>
      </section>
      <section>
        <h3 id="storing-json-data-common-approaches">Storing JSON Data: Common Approaches</h3>
        <p>Databases handle JSON storage differently:</p>
        <ol type="1">
          <li><strong>Dedicated JSON Data Types</strong>: Offer optimized storage and querying.
            <ul>
              <li><strong>PostgreSQL</strong>: <code>JSON</code> (stores exact text, preserves
                whitespace/order/duplicates) and <code>JSONB</code> (binary format, optimized for query/indexing,
                removes
                whitespace/duplicates, doesnâ€™t preserve order - <strong>generally preferred</strong>).</li>
              <li><strong>MySQL</strong>: <code>JSON</code> type (implemented as an optimized binary format since 5.7).
              </li>
              <li><strong>Oracle</strong>: <code>JSON</code> type (can be stored internally as <code>VARCHAR2</code>,
                <code>CLOB</code>, or <code>BLOB</code>, with specific constraints).
              </li>
              <li><strong>SQLite</strong>: <code>JSON</code> stored as <code>TEXT</code>, but with JSON functions
                available.</li>
            </ul>
          </li>
          <li><strong>Text-Based Storage with JSON Functions</strong>: Store JSON as <code>TEXT</code>,
            <code>VARCHAR(MAX)</code>, <code>CLOB</code>, etc., and use built-in functions to parse and query.
            <ul>
              <li><strong>SQL Server</strong>: Uses <code>NVARCHAR(MAX)</code> and provides extensive functions
                (<code>JSON_VALUE</code>, <code>JSON_QUERY</code>, <code>OPENJSON</code>, <code>ISJSON</code>, etc.).
              </li>
              <li><strong>Db2</strong>: Often stored in <code>VARCHAR</code>, <code>CLOB</code>, or <code>BLOB</code>,
                with JSON SQL functions for interaction.</li>
            </ul>
          </li>
        </ol>
        <p><strong>Choosing an Approach</strong>: Using dedicated JSON types (like PostgreSQL <code>JSONB</code> or
          MySQL
          <code>JSON</code>) is generally recommended when available, as they offer performance benefits and specialized
          indexing.
        </p>
      </section>
      <section>
        <h3 id="querying-json-data-operators-and-functions">Querying JSON Data: Operators and Functions</h3>
        <p>The syntax for extracting data from JSON columns varies significantly.</p>
        <p><strong>1. Path Navigation</strong>: Accessing specific values within a JSON object or array.</p>
        <ul>
          <li><strong>PostgreSQL</strong>: Uses operators <code>-&gt;</code> (get element/field as JSON/JSONB),
            <code>-&gt;&gt;</code> (get as text), <code>#&gt;</code> (get element/field at path as JSON/JSONB),
            <code>#&gt;&gt;</code> (get at path as text).
            <div class="sourceCode" id="cb1">
              <pre
                class="sourceCode sql"><code class="sourceCode sql"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">-- PostgreSQL Examples</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">SELECT</span> data_column-&gt;'user'-&gt;&gt;'name' <span class="kw">FROM</span> logs <span class="kw">WHERE</span> id = 1;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="kw">SELECT</span> data_column#&gt;&gt;'{address,city}' <span class="kw">FROM</span> users <span class="kw">WHERE</span> id = 1;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="kw">SELECT</span> data_column-&gt;'tags'-&gt;&gt;0 <span class="kw">FROM</span> posts <span class="kw">WHERE</span> id = 1; -- Access first array element</span></code></pre>
            </div>
          </li>
          <li><strong>MySQL</strong>: Uses <code>-&gt;</code> (equivalent to <code>JSON_EXTRACT</code>),
            <code>-&gt;&gt;</code> (extracts and unquotes).
            <div class="sourceCode" id="cb1">
              <pre
                class="sourceCode sql"><code class="sourceCode sql"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">-- PostgreSQL Examples</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">SELECT</span> data_column-&gt;'$.user.name' <span class="kw">FROM</span> logs <span class="kw">WHERE</span> id = 1;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="kw">SELECT</span> data_column-&gt;&gt;'$.user.name' <span class="kw">FROM</span> users <span class="kw">WHERE</span> id = 1;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="kw">SELECT</span> data_column-&gt;&gt;'$.tags[0]' <span class="kw">FROM</span> posts <span class="kw">WHERE</span> id = 1; -- Access first array element</span></code></pre>
            </div>
          </li>
          <li><strong>SQL Server</strong>: Uses <code>JSON_VALUE</code> (for scalar values) and <code>JSON_QUERY</code>
            (for objects/arrays).
            <div class="sourceCode" id="cb1">
              <pre
                class="sourceCode sql"><code class="sourceCode sql"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">-- SQL Server Examples</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">SELECT</span> JSON_VALUE(data_column, '$.user.name') <span class="kw">FROM</span> logs <span class="kw">WHERE</span> id = 1;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="kw">SELECT</span> JSON_QUERY(data_column, '$.address') <span class="kw">FROM</span> users <span class="kw">WHERE</span> id = 1;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="kw">SELECT</span> JSON_VALUE(data_column, '$.tags[0]') <span class="kw">FROM</span> posts <span class="kw">WHERE</span> id = 1;</span></code></pre>
            </div>
          </li>
          <li><strong>Oracle</strong>: Uses dot notation with JSON columns or <code>JSON_VALUE</code>,
            <code>JSON_QUERY</code>.
            <div class="sourceCode" id="cb1">
              <pre
                class="sourceCode sql"><code class="sourceCode sql"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">-- Oracle Examples (assuming 'data_column' is JSON type)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">SELECT</span> l.data_column.user.name <span class="kw">FROM</span> logs l <span class="kw">WHERE</span> id = 1;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="kw">SELECT</span> JSON_VALUE(data_column, '$.address.city') <span class="kw">FROM</span> users <span class="kw">WHERE</span> id = 1;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="kw">SELECT</span> JSON_VALUE(data_column, '$.tags[0]') <span class="kw">FROM</span> posts <span class="kw">WHERE</span> id = 1;</span></code></pre>
            </div>
          </li>
          <li><strong>Standard SQL/JSON Path</strong>: The <code>JSON_VALUE</code> and <code>JSON_QUERY</code> functions
            with SQL/JSON path language (<code>$</code> for root, <code>.</code> for members, <code>[]</code> for
            arrays)
            are becoming more standard.</li>
        </ul>
      </section>
      <section>
        <p><strong>2. Existence and Type Checks</strong>:</p>
        <ul>
          <li><strong>PostgreSQL (JSONB)</strong>: <code>?</code> (key exists), <code>?|</code> (any key exists),
            <code>?&amp;</code> (all keys exist).
            <div class="sourceCode" id="cb1">
              <pre
                class="sourceCode sql"><code class="sourceCode sql"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a></span><span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">SELECT</span> * <span class="kw">FROM</span> users <span class="kw">WHERE</span> data_column ? 'address';</span><span class="co">-- PostgreSQL Example</span></code></pre>
            </div>
          </li>
          <li><strong>MySQL</strong>: <code>JSON_CONTAINS_PATH</code>, <code>JSON_KEYS</code>, <code>JSON_TYPE</code>.
            <div class="sourceCode" id="cb1">
              <pre
                class="sourceCode sql"><code class="sourceCode sql"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a></span><span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">SELECT</span> * <span class="kw">FROM</span> users <span class="kw">WHERE</span> JSON_CONTAINS_PATH(data_column, 'one', '$.address');</span><span class="co">-- MySQL Example</span></code></pre>
            </div>
          </li>
          <li><strong>SQL Server</strong>: <code>ISJSON</code> function, <code>JSON_VALUE</code> returning NULL if path
            doesnâ€™t exist.
            <div class="sourceCode" id="cb1">
              <pre
                class="sourceCode sql"><code class="sourceCode sql"><span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">SELECT</span> * <span class="kw">FROM</span> users <span class="kw">WHERE</span> ISJSON(data_column) &gt; 0 AND JSON_VALUE(data_column, '$.address') IS NOT NULL;</span><span class="co">-- SQL Server Example</span></code></pre>
            </div>
          </li>
          <li><strong>Oracle</strong>: <code>IS JSON</code> condition, <code>JSON_EXISTS</code> function.
            <div class="sourceCode" id="cb1">
              <pre
                class="sourceCode sql"><code class="sourceCode sql"><span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">SELECT</span> * <span class="kw">FROM</span> users <span class="kw">WHERE</span> data_column IS JSON AND JSON_EXISTS(data_column, '$.address');</span><span class="co">-- Oracle Example</span></code></pre>
            </div>
          </li>
        </ul>
        <p><strong>3. Searching within JSON (Containment)</strong>:</p>
        <ul>
          <li><strong>PostgreSQL (JSONB)</strong>: <code>@&gt;</code> (contains), <code>&lt;@</code> (is contained by).
            <div class="sourceCode" id="cb1">
              <pre
                class="sourceCode sql"><code class="sourceCode sql"><span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">SELECT</span> * <span class="kw">FROM</span> users <span class="kw">WHERE</span> data_column-&gt;'tags' @&gt; '"admin"'::jsonb;
<span class="co">-- PostgreSQL Example: Find users with a specific tag</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="kw">SELECT</span> * <span class="kw">FROM</span> users <span class="kw">WHERE</span> data_column &lt;@ '{"roles": ["editor"], "status": "active"}'::jsonb;</span></code></pre>
            </div>
          </li>
          <li><strong>MySQL</strong>: <code>JSON_CONTAINS</code>, <code>JSON_SEARCH</code>.
            <div class="sourceCode" id="cb1">
              <pre
                class="sourceCode sql"><code class="sourceCode sql"><span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">SELECT</span> * <span class="kw">FROM</span> users <span class="kw">WHERE</span> JSON_CONTAINS(data_column-&gt;'$.tags', '"admin"');</span><span class="co">-- MySQL Example: Find users with a specific tag</span></code></pre>
            </div>
          </li>
          <li><strong>SQL Server/Oracle</strong>: Often requires extracting values or using path existence checks.</li>
        </ul>
        <p><strong>4. Functions for Arrays and Objects</strong>: Functions to get array length, object keys, expand
          arrays/objects into rows are common but vary.</p>
        <ul>
          <li><strong>PostgreSQL</strong>: <code>jsonb_array_length</code>, <code>jsonb_object_keys</code>,
            <code>jsonb_array_elements</code>, <code>jsonb_each</code>.
          </li>
          <li><strong>MySQL</strong>: <code>JSON_LENGTH</code>, <code>JSON_KEYS</code>, <code>JSON_TABLE</code>
            (powerful
            function to turn JSON into relational rows).</li>
          <li><strong>SQL Server</strong>: <code>JSON_QUERY</code> (for arrays), <code>OPENJSON</code> (very powerful
            function to turn JSON into relational rows).</li>
          <li><strong>Oracle</strong>: <code>JSON_TABLE</code> (standard and powerful).</li>
        </ul>
      </section>
      <section>
        <h3 id="indexing-json-data">Indexing JSON Data</h3>
        <p>Efficiently querying large amounts of JSON data requires indexing. Strategies depend heavily on the database
          system and storage format.</p>
        <ol type="1">
          <li>
            <p><strong>Indexing Specific Fields</strong>: Create standard B-tree indexes on scalar values extracted from
              JSON using functions or path operators. This works well for equality or range queries on known, frequently
              queried fields.</p>
            <div class="sourceCode" id="cb1">
              <pre
                class="sourceCode sql"><code class="sourceCode sql"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">-- PostgreSQL Example</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">CREATE</span> <span class="kw">INDEX</span> idx_user_email <span class="kw">ON</span> users ((data_column<span class="op">-&gt;&gt;</span><span class="st">&#39;email&#39;</span>));</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="co">-- MySQL Example (Generated Column)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="kw">ALTER</span> <span class="kw">TABLE</span> users <span class="kw">ADD</span> <span class="kw">COLUMN</span> email_virtual <span class="dt">VARCHAR</span>(<span class="dv">100</span>) </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    <span class="kw">GENERATED</span> ALWAYS <span class="kw">AS</span> (data_column<span class="op">-&gt;&gt;</span><span class="st">&#39;$.email&#39;</span>) STORED;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="kw">CREATE</span> <span class="kw">INDEX</span> idx_user_email <span class="kw">ON</span> users (email_virtual);</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a><span class="co">-- SQL Server Example (Computed Column)</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a><span class="kw">ALTER</span> <span class="kw">TABLE</span> users <span class="kw">ADD</span> email_computed <span class="kw">AS</span> JSON_VALUE(data_column, <span class="st">&#39;$.email&#39;</span>);</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a><span class="kw">CREATE</span> <span class="kw">INDEX</span> idx_user_email <span class="kw">ON</span> users (email_computed);</span></code></pre>
            </div>
          </li>
          <li>
            <p><strong>Full JSON Indexing (GIN/Inverted Indexes)</strong>: Index the entire JSON structure to support
              diverse queries, including containment (<code>@&gt;</code>) and existence (<code>?</code>) checks.
              Typically
              used with binary JSON types.</p>
            <ul>
              <li><strong>PostgreSQL</strong>: <code>USING GIN (jsonb_column)</code> or
                <code>USING GIN (jsonb_column jsonb_path_ops)</code>.
              </li>
              <li><strong>MySQL</strong>: Multi-valued indexes on JSON arrays or functional indexes.</li>
              <li><strong>Oracle</strong>: <code>JSON_SEARCH</code> index, functional indexes.</li>
              <li><strong>SQL Server</strong>: Full-text indexes can sometimes be used, or indexes on computed columns
                representing paths.</li>
            </ul>
          </li>
        </ol>
        <p>Choosing the right indexing strategy depends on the specific queries you need to optimize.</p>
      </section>
      <section>
        <h3 id="transforming-and-modifying-json">Transforming and Modifying JSON</h3>
        <p>Databases provide functions to build, modify, and transform JSON data.</p>
        <p><strong>1. Building JSON</strong>: Creating JSON objects or arrays from relational data. *
          <strong>PostgreSQL</strong>: <code>jsonb_build_object</code>, <code>jsonb_build_array</code>,
          <code>jsonb_agg</code>, <code>jsonb_object_agg</code>. * <strong>MySQL</strong>: <code>JSON_OBJECT</code>,
          <code>JSON_ARRAY</code>, <code>JSON_ARRAYAGG</code>, <code>JSON_OBJECTAGG</code>. * <strong>SQL
            Server</strong>:
          <code>FOR JSON PATH</code> or <code>FOR JSON AUTO</code> clauses in <code>SELECT</code> statements. *
          <strong>Oracle</strong>: <code>JSON_OBJECT</code>, <code>JSON_ARRAY</code>, <code>JSON_OBJECTAGG</code>,
          <code>JSON_ARRAYAGG</code>.
        </p>
        <p><strong>2. Modifying JSON</strong>: Updating parts of a JSON document. * <strong>PostgreSQL</strong>:
          <code>jsonb_set</code> function, <code>||</code> operator (merge), <code>-</code> operator (delete key),
          <code>#-</code> operator (delete path). * <strong>MySQL</strong>: <code>JSON_SET</code>,
          <code>JSON_INSERT</code>, <code>JSON_REPLACE</code>, <code>JSON_REMOVE</code>. * <strong>SQL Server</strong>:
          <code>JSON_MODIFY</code>. * <strong>Oracle</strong>: <code>JSON_MERGEPATCH</code>,
          <code>JSON_TRANSFORM</code>.
        </p>
        <p><strong>3. Converting JSON to Relational</strong>: Expanding JSON structures into rows and columns. *
          <strong>PostgreSQL</strong>: <code>jsonb_array_elements</code>, <code>jsonb_each</code>,
          <code>jsonb_to_record</code>, <code>jsonb_to_recordset</code>. * <strong>MySQL</strong>:
          <code>JSON_TABLE</code>. * <strong>SQL Server</strong>: <code>OPENJSON</code>. * <strong>Oracle</strong>:
          <code>JSON_TABLE</code>.
        </p>
        <h3 id="use-cases-and-best-practices">Use Cases and Best Practices</h3>
        <p><strong>Common Use Cases for JSON in RDBMS</strong>: - Storing flexible or evolving attributes (e.g., product
          specifications, user preferences). - Logging events with variable structures. - Storing configuration data. -
          Caching data from external APIs. - Handling data from web frontends.</p>
        <p><strong>Best Practices</strong>: - <strong>Use Binary Formats (JSONB, MySQL JSON) When Possible</strong>:
          Generally better performance and indexing for querying. - <strong>Normalize When Appropriate</strong>: Donâ€™t
          overuse JSON. If a piece of data has a fixed structure, is frequently queried or updated independently, or
          needs
          strong relational integrity (foreign keys), it probably belongs in its own column or table. - <strong>Index
            Strategically</strong>: Index specific, frequently queried paths or use full JSON indexes (like GIN) based
          on
          query patterns. - <strong>Validate JSON</strong>: Use database constraints (<code>IS JSON</code> checks) or
          application logic to ensure stored data is valid JSON. - <strong>Understand Syntax Differences</strong>: Be
          aware that JSON functions and operators are highly vendor-specific.</p>
        <p>Working with JSON data effectively combines the flexibility of NoSQL with the robustness and querying power
          of
          relational databases, but requires understanding the specific capabilities and syntax of your chosen RDBMS.
        </p>
      </section>
    </div>
  </div>
</body>
</div>
</div> <!-- /container -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
  integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
<script src="../static/script.js"></script>

</html>